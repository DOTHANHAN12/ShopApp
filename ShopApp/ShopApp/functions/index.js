const { onDocumentCreated, onDocumentUpdated } = require('firebase-functions/v2/firestore');
const { onSchedule } = require('firebase-functions/v2/scheduler');
const { onRequest } = require('firebase-functions/v2/https');
const { setGlobalOptions } = require('firebase-functions/v2');
const { logger } = require('firebase-functions');
const admin = require('firebase-admin');

// --- KH·ªûI T·∫†O CH√çNH (Ch·ªâ c·∫ßn 1 l·∫ßn) ---
admin.initializeApp();
const db = admin.firestore();
const messaging = admin.messaging();

// --- C√ÄI ƒê·∫∂T TO√ÄN C·ª§C CHO FUNCTIONS ---
setGlobalOptions({
    region: 'asia-east1',
    maxInstances: 10,
    timeoutSeconds: 540,
    memory: '512MiB',
});

// --- T√äN C√ÅC COLLECTION ---
const SCHEDULED_NOTIFICATIONS_COLLECTION = 'scheduledNotifications';
const USER_NOTIFICATIONS_COLLECTION = 'notifications';
const ORDERS_COLLECTION = 'orders';

// ============================================================================
// üîî TRIGGER - KHI TR·∫†NG TH√ÅI ƒê∆†N H√ÄNG THAY ƒê·ªîI, G·ª¨I TH√îNG B√ÅO
// ============================================================================
exports.onOrderStatusChanged = onDocumentUpdated(ORDERS_COLLECTION + '/{orderId}', async (event) => {
    const before = event.data.before.data();
    const after = event.data.after.data();
    const orderId = event.params.orderId;

    if (before.orderStatus === after.orderStatus) {
        logger.info(`Order ${orderId}: Status not changed, skipping.`);
        return null;
    }

    // ‚≠êÔ∏è FIX: L·∫•y userId c·ªßa ch·ªß ƒë∆°n h√†ng t·ª´ d·ªØ li·ªáu TR∆Ø·ªöC khi thay ƒë·ªïi.
    // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o th√¥ng b√°o lu√¥n ƒë∆∞·ª£c g·ª≠i cho ƒë√∫ng kh√°ch h√†ng,
    // ngay c·∫£ khi trang admin c√≥ v√¥ t√¨nh ghi ƒë√® userId.
    const customerId = before.userId;
    if (!customerId) {
        logger.error(`Order ${orderId}: Missing 'userId' in order data. Cannot send notification.`);
        return null;
    }

    logger.info(`Order ${orderId}: Status changed from '${before.orderStatus}' to '${after.orderStatus}'. Notifying user: ${customerId}`);

    const notificationContent = getOrderStatusNotification(after.orderStatus, orderId);
    if (!notificationContent) {
        logger.info(`No notification defined for status: ${after.orderStatus}`);
        return null;
    }

    try {
        // ‚≠êÔ∏è G·ª¨I RI√äNG CHO CH·ª¶ ƒê∆†N H√ÄNG - KH√îNG BROADCAST
        const topic = `user_${customerId}`;
        const message = {
            topic: topic,  // ‚úÖ G·ª≠i CH·ªàNH X√ÅC ƒë·∫øn topic c·ªßa user
            notification: {
                title: notificationContent.title,
                body: notificationContent.body,
            },
            data: {
                title: String(notificationContent.title),
                body: String(notificationContent.body),
                type: 'ORDER',
                actionType: 'OPEN_ORDER',
                actionData: String(orderId),
                icon: 'cart',
                priority: String(notificationContent.priority),
                userId: String(customerId),  // ‚≠êÔ∏è TH√äM D√íNG N√ÄY - g·ª≠i userId cho Android app l∆∞u ƒë√∫ng user
            },
            android: {
                priority: 'high',
                notification: {
                    sound: 'default',
                    channelId: 'fcm_default_channel',
                    icon: 'ic_notification',
                    color: notificationContent.color,
                },
            },
        };

        const response = await messaging.send(message);
        logger.info(`‚úÖ Sent order notification ONLY to owner [${customerId}] for order [${orderId}]`, { messageId: response });

        // ‚≠êÔ∏è Ch·ªâ l∆∞u notification v√†o collection c·ªßa CH·ª¶ƒê∆†N H√ÄNG
        await saveOrderNotificationToUser(customerId, orderId, notificationContent);

        return { success: true, messageId: response, notifiedUser: customerId };

    } catch (error) {
        logger.error(`‚ùå Error sending order notification for user ${customerId}:`, error);
        return { success: false, error: error.message };
    }
});


// ============================================================================
// üìù HELPER - L·∫•y n·ªôi dung th√¥ng b√°o d·ª±a tr√™n tr·∫°ng th√°i ƒë∆°n h√†ng
// ============================================================================
function getOrderStatusNotification(status, orderId) {
    const orderShortId = orderId.substring(0, 8).toUpperCase();

    switch (status) {
        case 'CONFIRMED': return { title: '‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n', body: `ƒê∆°n h√†ng #${orderShortId} ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n v√† ƒëang ƒë∆∞·ª£c chu·∫©n b·ªã.`, priority: 2, color: '#2196F3' };
        case 'PROCESSING': return { title: 'üì¶ ƒê∆°n h√†ng ƒëang x·ª≠ l√Ω', body: `ƒê∆°n h√†ng #${orderShortId} ƒëang ƒë∆∞·ª£c ƒë√≥ng g√≥i.`, priority: 1, color: '#9C27B0' };
        case 'SHIPPING': return { title: 'üöö ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c giao', body: `ƒê∆°n h√†ng #${orderShortId} ƒëang tr√™n ƒë∆∞·ªùng giao ƒë·∫øn b·∫°n.`, priority: 2, color: '#00BCD4' };
        case 'DELIVERED': return { title: '‚úì ƒê∆°n h√†ng ƒë√£ giao th√†nh c√¥ng', body: `ƒê∆°n h√†ng #${orderShortId} ƒë√£ ƒë∆∞·ª£c giao ƒë·∫øn b·∫°n. C·∫£m ∆°n b·∫°n ƒë√£ mua h√†ng!`, priority: 2, color: '#4CAF50' };
        case 'COMPLETED': return { title: 'üéâ ƒê∆°n h√†ng ƒë√£ ho√†n t·∫•t', body: `ƒê∆°n h√†ng #${orderShortId} ƒë√£ ho√†n t·∫•t. H√£y ƒë√°nh gi√° s·∫£n ph·∫©m nh√©!`, priority: 1, color: '#4CAF50' };
        case 'CANCELLED': return { title: '‚ùå ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy', body: `ƒê∆°n h√†ng #${orderShortId} c·ªßa b·∫°n ƒë√£ b·ªã h·ªßy.`, priority: 2, color: '#F44336' };
        case 'REFUNDED': return { title: 'üí∞ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn', body: `ƒê∆°n h√†ng #${orderShortId} ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn.`, priority: 2, color: '#607D8B' };
        case 'PAID': return { title: 'üí≥ Thanh to√°n th√†nh c√¥ng', body: `ƒê∆°n h√†ng #${orderShortId} ƒë√£ ƒë∆∞·ª£c thanh to√°n th√†nh c√¥ng.`, priority: 2, color: '#4CAF50' };
        default: return null;
    }
}

// ============================================================================
// üíæ HELPER - L∆∞u th√¥ng b√°o ƒë∆°n h√†ng v√†o collection c·ªßa ng∆∞·ªùi d√πng
// ============================================================================
async function saveOrderNotificationToUser(userId, orderId, content) {
    const notificationRef = db.collection(USER_NOTIFICATIONS_COLLECTION).doc();
    await notificationRef.set({
        notificationId: notificationRef.id,
        userId: userId,
        title: content.title,
        body: content.body,
        imageUrl: '',
        type: 'ORDER',
        actionType: 'OPEN_ORDER',
        actionData: orderId,
        icon: 'cart',
        priority: content.priority,
        isRead: false,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
        senderName: 'H·ªá th·ªëng',
        extraData: { orderId: orderId },
    });
    logger.info(`‚úÖ Saved order notification to user's collection: ${userId}`);
}


// ============================================================================
//          C√ÅC H√ÄM G·ª¨I TH√îNG B√ÅO CHUNG (T·ª™ WEB ADMIN) - BROADCAST
// ============================================================================

function buildFCMMessage(notification) {
    const message = {
        topic: 'all_users',  // ‚úÖ G·ª≠i cho T·∫§T C·∫¢ m·ªçi ng∆∞·ªùi
        notification: {
            title: notification.title || 'Th√¥ng b√°o m·ªõi',
            body: notification.body || '',
        },
        data: {
            title: String(notification.title || ''),
            body: String(notification.body || ''),
            type: String(notification.type || 'SYSTEM'),
            actionType: String(notification.actionType || 'NONE'),
            actionData: String(notification.actionData || ''),
            icon: String(notification.icon || 'bell'),
            priority: String(notification.priority || 1),
            imageUrl: String(notification.imageUrl || ''),
            // ‚≠êÔ∏è Kh√¥ng g·ª≠i userId ·ªü broadcast - v√¨ l√† th√¥ng b√°o chung
        },
        android: {
            priority: (notification.priority || 1) >= 2 ? 'high' : 'normal',
            notification: {
                sound: 'default',
                channelId: 'fcm_default_channel',
                icon: 'ic_notification',
                color: '#667eea',
                priority: (notification.priority || 1) >= 2 ? 'high' : 'default',
            },
        },
    };
    if (notification.imageUrl) {
        message.notification.imageUrl = notification.imageUrl;
    }
    return message;
}

async function sendFCMNotification(notification) {
    try {
        const message = buildFCMMessage(notification);
        logger.info('Sending broadcast FCM with data:', { title: notification.title, type: notification.type });
        const response = await messaging.send(message);
        logger.info('‚úÖ Broadcast FCM sent successfully:', response);
        return { success: true, messageId: response, error: null };
    } catch (error) {
        logger.error('‚ùå Broadcast FCM error:', error);
        return { success: false, messageId: null, error: error.message };
    }
}

async function saveNotificationToAllUsers(notification) {
    try {
        const usersSnapshot = await db.collection('users').limit(1000).get();
        const batch = db.batch();
        let count = 0;

        for (const userDoc of usersSnapshot.docs) {
            const notificationRef = db.collection(USER_NOTIFICATIONS_COLLECTION).doc();
            batch.set(notificationRef, {
                notificationId: notificationRef.id,
                userId: userDoc.id,
                title: notification.title || '',
                body: notification.body || '',
                imageUrl: notification.imageUrl || '',
                type: notification.type || 'SYSTEM',
                actionType: notification.actionType || 'NONE',
                actionData: notification.actionData || '',
                icon: notification.icon || 'bell',
                priority: notification.priority || 1,
                isRead: false,
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                senderName: 'H·ªá th·ªëng',
                extraData: {},
            });

            count++;
            if (count % 500 === 0) {
                await batch.commit();
            }
        }

        if (count % 500 > 0) {
            await batch.commit();
        }

        logger.info(`‚úÖ Saved broadcast notification to ${usersSnapshot.size} users.`);
    } catch (error) {
        logger.error('‚ùå Error saving broadcast notification to all users:', error);
    }
}

async function updateScheduledNotificationStatus(docId, status, additionalData = {}) {
    await db.collection(SCHEDULED_NOTIFICATIONS_COLLECTION).doc(docId).update({
        status,
        lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
        ...additionalData,
    });
}

// ============================================================================
// ‚è∞ SCHEDULER - Ki·ªÉm tra th√¥ng b√°o ƒë√£ l√™n l·ªãch v√† g·ª≠i
// ============================================================================
exports.checkScheduledNotifications = onSchedule('every 5 minutes', async (event) => {
    const now = Date.now();
    const snapshot = await db.collection(SCHEDULED_NOTIFICATIONS_COLLECTION)
        .where('status', '==', 'PENDING').where('scheduleTime', '<=', now).limit(100).get();

    if (snapshot.empty) return null;

    logger.info(`Found ${snapshot.size} scheduled notifications to process.`);
    for (const doc of snapshot.docs) {
        const notification = { id: doc.id, ...doc.data() };
        const sendResult = await sendFCMNotification(notification);
        if (sendResult.success) {
            await updateScheduledNotificationStatus(doc.id, 'SENT', {
                sentTime: admin.firestore.FieldValue.serverTimestamp(),
                messageId: sendResult.messageId
            });
            await saveNotificationToAllUsers(notification);
        } else {
            await updateScheduledNotificationStatus(doc.id, 'FAILED', {
                failedTime: admin.firestore.FieldValue.serverTimestamp(),
                errorMessage: sendResult.error
            });
        }
    }
    return { processed: snapshot.size };
});